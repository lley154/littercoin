minting littercoin

struct Datum {
    adaAmount: Int
    lcAmount: Int

    func get_ratio(self) -> Int {
        self.adaAmount / self.lcAmount
    }
}

enum Redeemer { 
    Mint {
        lcValHashBA: ByteArray
    }
    Burn {
        lcValHashBA: ByteArray
    }
 }

// Define thread token value
const TT_MPH: ByteArray = #98389e427873c17d340d352fccfa4f465fdab4404fc29e4eda71d686
const ttMph: MintingPolicyHash = MintingPolicyHash::new(TT_MPH)
const ttAssetclass: AssetClass = AssetClass::new(
        ttMph, 
        "Thread Token Littercoin".encode_utf8()
    )
const ttVal : Value = Value::new(ttAssetclass, 1)

func getDatumOut (txOuts : []TxOutput) -> []TxOutput {

    if (txOuts.is_empty()) {
        txOuts
    } else {
            txOuts.head.datum.switch {
            Inline => { []TxOutput::new_const(1, txOuts.head) },
            else => getDatumOut(txOuts.tail)
            }
    }
}

func getDatumIn (txIns : []TxInput) -> OutputDatum {

    if (txIns.is_empty()) {
        OutputDatum::new_none()
    } else {
        txIns.head.output.datum.switch {
            dat: Inline => { 
                OutputDatum::new_inline(dat.data)
            },
            else => getDatumIn(txIns.tail)
        }
    }
}


func main(redeemer: Redeemer, ctx: ScriptContext) -> Bool {
    
    tx: Tx = ctx.tx;

    redeemer.switch {
        red: Mint => {
                // Confirmed minted value and check that thread token is part of this transaction
                vHash: ValidatorHash = ValidatorHash::new(red.lcValHashBA); 
                txOutputs: []TxOutput = tx.outputs_locked_by(vHash);
                txOut: []TxOutput = getDatumOut(txOutputs);
                //txIn: []TxOutput = getDatumIn(tx.inputs);
                txIn: []TxOutput = getDatumIn(tx.inputs).switch {
                    txDat: Some => { txDat },
                    else => error("LCMP1") // no datum found in inputs
                };

                if (!txOut.is_empty()) {
                    txOut.head.datum.switch {
                        outDat: Inline => { 
                            getDatumIn(tx.inputs).switch {
                                inDat: Inline => {
                                    datumOut: Datum = Datum::from_dat(outDat.data);
                                    datumIn: Datum = Datum::from_dat(inDat.data);
                                    lcDatAmount: Int = datumOut.lcAmount - datumIn.lcAmount;
                                    lcMintVal: Value = Value::new(lcAssetClass, lcDatAmt);

                                    (tx.minted == lcMintVal).trace("LCMP1: ") &&
                                    (txOut.head.value ==  (ttVal + adaVal)).trace("LCM2: ")
                                    //(tx.value_locked_by(vHash) == (ttVal + adaVal)).trace("LCM2: ")
                                },
                                else => false.trace("LCMP3") // No input inline datum found
                            }
                        },
                        else => false.trace("LCMP4") // No output inline datum found
                    }
                } else {
                    false.trace("LCMP5: ") // No valid inputs and outputs found 
                }
        },
        red: Burn => {
                // Check that thread token is part of this transaction
                vHash: ValidatorHash = ValidatorHash::new(red.lcValHashBA); 
                tx.value_locked_by(vHash).contains(ttVal).trace("MLC2: ")
        }
    }
}

const MINT_REDEEMER = Redeemer::Mint{#1a2b3c}
const BURN_REDEEMER = Redeemer::Burn{#1a2b3c}
